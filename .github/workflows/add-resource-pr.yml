name: Add Resource PR
on:
  issues:
    types: [opened, edited]

permissions:
  contents: write
  pull-requests: write
  issues: read

jobs:
  build-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Parse issue and update JSON
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const body = context.payload.issue.body || '';
            const issueTitle = context.payload.issue.title || '';

            // --- Parse all ### blocks into a map (robust to spacing/diacritics) ---
            const blockRe = /^\s*###\s*(.+?)\s*$\r?\n+([\s\S]*?)(?=^\s*###\s|$)/gim;
            const blocks = {};
            function normLabel(s){
              return String(s || '')
                .toLowerCase()
                .normalize('NFKD')
                .replace(/[\u0300-\u036f]/g, '')  // strip diacritics
                .replace(/[^a-z0-9]+/g,' ')
                .trim()
                .replace(/\s+/g,' ');
            }
            let m;
            while ((m = blockRe.exec(body)) !== null) {
              const label = normLabel(m[1]);
              const value = (m[2] || '').trim();
              blocks[label] = value;
            }

            function getAny(labels){
              for (const lab of labels){
                const v = blocks[normLabel(lab)];
                if (v) return v.trim();
              }
              return '';
            }

            function clean(v){
              return (v || '')
                .replace(/^`+|`+$/g, '')
                .replace(/^"+|"+$/g, '')
                .replace(/\r/g,'')
                .trim();
            }

            function firstUrlFallback(s){
              const re = /(https?:\/\/[^\s)]+)/i;
              const mm = (s || body).match(re);
              return mm ? mm[1].trim() : '';
            }

            const rec = {
              title: clean(getAny(['Resource Name','Title'])) || clean(issueTitle),
              description: clean(getAny(['Description'])),
              category: clean(getAny(['Category'])),
              target_age_group: clean(getAny(['Target Age Group'])),
              resource_type: clean(getAny(['Resource Type'])),
              language: clean(getAny(['Language'])),
              url: clean(getAny(['URL'])) || firstUrlFallback(body),
              platform: clean(getAny(['Platform'])),
              publication_date: clean(getAny(['Publication Date']))
            };

            // Normalize platform to array when multiple are provided
            if (rec.platform) {
              const parts = rec.platform.split(/,|\n/).map(s=>s.trim()).filter(Boolean);
              rec.platform = parts.length > 1 ? parts : parts[0];
            }

            // Accept YYYY or YYYY-MM-DD
            if (/^\d{4}$/.test(rec.publication_date)) {
              rec.publication_date = rec.publication_date + '-01-01';
            } else if (rec.publication_date && !/^\d{4}-\d{2}-\d{2}$/.test(rec.publication_date)) {
              core.warning('Publication Date not ISO (YYYY or YYYY-MM-DD). Keeping raw: ' + rec.publication_date);
            }

            // Validate required fields
            const missing = [];
            if (!rec.title) missing.push('Resource Name (or Issue Title)');
            if (!rec.url) missing.push('URL');
            if (!rec.resource_type) missing.push('Resource Type');

            if (missing.length) {
              core.error('Normalized blocks: ' + JSON.stringify(blocks, null, 2));
              core.setFailed('Missing required fields: ' + missing.join(', ') + '.');
              return;
            }

            // URL sanity
            try { new URL(rec.url); } catch {
              core.error('Parsed URL was: ' + rec.url);
              core.setFailed('Invalid URL.');
              return;
            }

            const dataPath = path.join(process.env.GITHUB_WORKSPACE, 'data', 'resources.json');
            fs.mkdirSync(path.dirname(dataPath), { recursive: true });
            let items = [];
            if (fs.existsSync(dataPath)) {
              try { items = JSON.parse(fs.readFileSync(dataPath, 'utf8') || '[]'); }
              catch(e) { core.warning('resources.json not parseable; starting fresh.'); items = []; }
            }

            // Prevent dupes by URL (case-insensitive)
            if (items.some(it => String(it.url || '').toLowerCase() === rec.url.toLowerCase())) {
              core.warning('Duplicate URL detected; skipping append.');
              core.setOutput('skipped', 'true');
              return;
            }

            items.push(rec);
            items.sort((a,b)=>String(a.title||'').localeCompare(String(b.title||'')));
            fs.writeFileSync(dataPath, JSON.stringify(items, null, 2) + '\n');

            const slug = String(rec.title).toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
            core.setOutput('branch', `add-resource-${slug}`);

      - name: Create Pull Request
        if: steps.parse.outputs.skipped != 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          # If your org blocks PRs from GITHUB_TOKEN, add: token: ${{ secrets.PAT_PR }}
          branch: ${{ steps.parse.outputs.branch }}
          commit-message: "Add resource from issue #${{ github.event.issue.number }}"
          title: "Add resource: ${{ github.event.issue.title || 'New resource' }}"
          body: "Auto-generated from issue #${{ github.event.issue.number }}."
          labels: data
          add-paths: |
            data/resources.json
