      - name: Parse issue and update JSON
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const body = context.payload.issue.body || '';
            const issueTitle = context.payload.issue.title || '';

            // --- Parse all ### blocks into a map ---
            // Captures: heading text (group 1) + content until next heading (group 2)
            const blockRe = /^\\s*###\\s*(.+?)\\s*$\\r?\\n+([\\s\\S]*?)(?=^\\s*###\\s|$)/gim;
            const blocks = {};
            function normLabel(s){
              return String(s || '')
                .toLowerCase()
                .normalize('NFKD')
                .replace(/[\\u0300-\\u036f]/g, '')  // strip diacritics
                .replace(/[^a-z0-9]+/g,' ')         // non-alnum -> space
                .trim()
                .replace(/\\s+/g,' ');              // collapse spaces
            }
            let m;
            while ((m = blockRe.exec(body)) !== null) {
              const label = normLabel(m[1]);
              const value = (m[2] || '').trim();
              blocks[label] = value;
            }

            // helper to get a field by any of a set of label variants
            function getAny(labels){
              for (const lab of labels){
                const v = blocks[normLabel(lab)];
                if (v) return v.trim();
              }
              return '';
            }

            function clean(v){
              return (v || '')
                .replace(/^`+|`+$/g, '')
                .replace(/^"+|"+$/g, '')
                .replace(/\\r/g,'')
                .trim();
            }

            function firstUrlFallback(s){
              const re = /(https?:\\/\\/[^\\s)]+)/i;
              const mm = (s || body).match(re);
              return mm ? mm[1].trim() : '';
            }

            const rec = {
              title: clean(getAny(['Resource Name','Title'])) || clean(issueTitle),
              description: clean(getAny(['Description'])),
              category: clean(getAny(['Category'])),
              target_age_group: clean(getAny(['Target Age Group'])),
              resource_type: clean(getAny(['Resource Type'])),
              language: clean(getAny(['Language'])),
              url: clean(getAny(['URL'])) || firstUrlFallback(body),
              platform: clean(getAny(['Platform'])),
              publication_date: clean(getAny(['Publication Date']))
            };

            // Normalize platform -> array if comma/newline separated
            if (rec.platform) {
              const parts = rec.platform.split(/,|\\n/).map(s=>s.trim()).filter(Boolean);
              rec.platform = parts.length > 1 ? parts : parts[0];
            }

            // Publication date: accept YYYY or YYYY-MM-DD, keep raw otherwise
            if (/^\\d{4}$/.test(rec.publication_date)) {
              rec.publication_date = rec.publication_date + '-01-01';
            } else if (rec.publication_date && !/^\\d{4}-\\d{2}-\\d{2}$/.test(rec.publication_date)) {
              core.warning('Publication Date not ISO (YYYY or YYYY-MM-DD). Keeping raw: ' + rec.publication_date);
            }

            // Validate required with resilient fallbacks
            const missing = [];
            if (!rec.title) missing.push('Resource Name (or Issue Title)');
            if (!rec.url) missing.push('URL');
            if (!rec.resource_type) missing.push('Resource Type');

            if (missing.length) {
              core.error('Normalized blocks: ' + JSON.stringify(blocks, null, 2));
              core.setFailed('Missing required fields: ' + missing.join(', ') + '.');
              return;
            }

            try { new URL(rec.url); } catch {
              core.error('Parsed URL was: ' + rec.url);
              core.setFailed('Invalid URL.');
              return;
            }

            const dataPath = path.join(process.env.GITHUB_WORKSPACE, 'data', 'resources.json');
            fs.mkdirSync(path.dirname(dataPath), { recursive: true });
            let items = [];
            if (fs.existsSync(dataPath)) {
              try { items = JSON.parse(fs.readFileSync(dataPath, 'utf8') || '[]'); }
              catch(e) { core.warning('resources.json not parseable; starting fresh.'); items = []; }
            }

            // Prevent dupes by URL (case-insensitive)
            if (items.some(it => String(it.url || '').toLowerCase() === rec.url.toLowerCase())) {
              core.warning('Duplicate URL detected; skipping append.');
              core.setOutput('skipped', 'true');
              return;
            }

            items.push(rec);
            items.sort((a,b)=>String(a.title||'').localeCompare(String(b.title||'')));
            fs.writeFileSync(dataPath, JSON.stringify(items, null, 2) + '\\n');

            const slug = String(rec.title).toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
            core.setOutput('branch', `add-resource-${slug}`);
